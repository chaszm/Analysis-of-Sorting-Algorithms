# Optimal Sorting Algorithms for Varying Datasets


# Introduction and Project Overview

Sorting algorithms are an integral part of computer science with many real world applications. Our group was drawn to this topic because we know just how important learning how to utilize these algorithms is for our future jobs. These types of algorithms allow programmers to simplify complex problems, organize large data sets, and improve the efficiency of any program. By mastering sorting algorithms, programmers gain the ability to tackle intricate problems and overall enhance the efficiency and performance of their programs. Real world examples of these algorithms are seen within our everyday lives with Google Search or in E-Commerce stores.  This shows just how relevant this topic is in the field of computer science. 

Our project, Optimal Sorting Algorithms for Varying Datasets, had us focusing on analyzing six different sorting algorithms. The sorting algorithms that we chose to implement during this project were Insertion sort, Merge Sort, Heap Sort, Radix Sort, Quick Sort, and Bubble Sort. We decided on these six algorithms because they are very commonly used within the field of computer science. Throughout our project, we focused on fully understanding each algorithm, how they perform, when we should implement them, and how they compare to each other. Through trial and error we managed to come up with a strategy to accurately record the data from each algorithm in order to compare them to one another. In the end, we accurately implemented, analyzed, and compared each of our algorithms through the data that we compiled.


# Aims and Objectives

Our group had a pretty straight forward plan to accurately analyze our algorithms. We quickly came up with a roadmap that had clear cut goals which assisted us with the completion of our task. The goals that we set were: Implementation of the algorithms, Analysis of each algorithm including time and space complexity, and finally compare and contrast each of our algorithms with each other. This set of clear goals helped our group to stay on the right path and achieve completion of our project. 

We started by splitting up the work between the three group members. Each member was assigned two algorithms to implement. We thought that splitting it up in this manner would allow us to quickly progress to the next goal that we had set. We decided to use Java as our programming language for this project as we are all very comfortable with the language. Once each member had successfully implemented, the next step was to analyze each algorithm. We again stuck to our two algorithms per group member. The first step of analysis was to gather the data for each algorithm. Once we developed a method to gather this data, we then created graphs for each sort. For the last step of analysis, we computed the time and space complexity for each of our sorts. The last goal that we had set was to compare each of our algorithms in order to determine similarities and differences between them. We did this by comparing the graphs, time and space complexities, and finally by the class of functions that each algorithm fell into. Overall, we set clear cut goals to implement, analyze, and compare our algorithms to one another. Without these goals, we would have lacked much of the needed efficiency and quality that this project required.


# Methodologies - System Configuration and Setup
